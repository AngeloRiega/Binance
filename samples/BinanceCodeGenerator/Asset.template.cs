// ReSharper disable InconsistentNaming
using System;
using System.Collections.Generic;

namespace Binance
{
    /// <summary>
    /// Defined assets (for convenience/reference only).
    /// </summary>
    public sealed class Asset : IComparable<Asset>, IEquatable<Asset>
    {
        #region Public Constants

        /// <summary>
        /// When the assets were last updated.
        /// </summary>
        // <<insert timestamp>>

        // Redirect (BCH) Bitcoin Cash (BCC = BitConnect)
        public static readonly Asset BCH = BCC;
        
        // <<insert assets>>

        #endregion Public Constants

        #region Implicit Operators

        public static implicit operator string(Asset asset) => asset.ToString();

        public static implicit operator Asset(string s) => Cache.ContainsKey(s) ? Cache[s] : null;

        #endregion Implicit Operators

        #region Public Properties

        /// <summary>
        /// Asset cache.
        /// </summary>
        public static readonly IDictionary<string, Asset> Cache = new Dictionary<string, Asset>()
        {
            // Redirect (BCH) Bitcoin Cash (BCC = BitConnect)
            { "BCH", BCC },

            // <<insert asset definitions>>
        };

        /// <summary>
        /// Get the asset symbol.
        /// </summary>
        public string Symbol { get; }

        /// <summary>
        /// Get the asset precision.
        /// </summary>
        public int Precision { get; }

        #endregion Public Properties

        #region Constructors

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="symbol">The asset symbol.</param>
        /// <param name="precision">The asset precision.</param>
        public Asset(string symbol, int precision)
        {
            if (string.IsNullOrWhiteSpace(symbol))
                throw new ArgumentNullException(nameof(symbol));

            if (precision <= 0)
                throw new ArgumentException($"Asset precision must be greater than 0.", nameof(precision));

            Symbol = symbol;
            Precision = precision;
        }

        #endregion Constructors

        #region Public Methods

        public override bool Equals(object obj)
        {
            return Symbol.Equals(obj);
        }

        public override int GetHashCode()
        {
            return Symbol.GetHashCode();
        }

        public override string ToString()
        {
            return Symbol;
        }

        #endregion Public Methods

        #region IComparable<Asset>

        public int CompareTo(Asset other)
        {
            if (other == null)
                return 1;

            return Symbol.CompareTo(other.Symbol);
        }

        #endregion IComparable<Asset>

        #region IEquatable<Asset>

        public bool Equals(Asset other)
        {
            return CompareTo(other) == 0;
        }

        #endregion IEquatable<Asset>

        // File generated by BinanceCodeGenerator tool.
    }
}
